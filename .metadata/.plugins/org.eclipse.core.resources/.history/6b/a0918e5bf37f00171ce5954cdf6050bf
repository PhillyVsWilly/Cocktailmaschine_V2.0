#include "Module_6_Handling.h"
#include "Evaluation.h"
#include "linked_list.h"

System_State_t* ptr_system_state;

typedef struct {
	ingredient_t ingredient;
	int module;
}module_ingredient_t;

void vInit_Module_3_Pumping(System_State_t* SystemState)
{
	//Nicht Ã¤dern, muss so sein!
	ptr_system_state = SystemState;

	init_drink_lists()

	// Hier kÃ¶nnen jetzt noch - falls nÃ¶tig - Startwerte fÃ¼r die anderen Zustandsvariablen gegeben werden
}


void vEvaluate_Module_6_Handling(InputValues_t input, Module_State_6_Handling_t* state, OutputValues_t* output)
{
	return;
}

void init_drink_lists()
{
	/*
	 * TODO Olaf
	 * Bitte hier die Trinklisten mit leeren EintrÃ¤gen in folgender Reihenfolge vorinitialisieren:
	 * Eis: 1 Leerplatz
	 * Schwerkraft: 2 LeerplÃ¤tze
	 * Pumpen: 3
	 * Einschenken: 4
	 * Die Listen bekommst du Ã¼ber ptr_system_state
	 * Z.B. list_append(ptr_system_state->Gravity.drink_list
	 *
	 * For-Schleife verwenden...
	 */

	//Leerer Eintrag, kann wiederverwendet werden.
	ingredient_t empty;
	empty.amount = -1;
	empty.bottleID = 0;
	empty.lastInstruction = TRUE;

	//HinzufÃ¼gen eines leeren Eintrags, wiederholen fÃ¼r mehrere leere EintrÃ¤ge
	list_append(*(ptr_system_state->Ice.drink_list), empty);
}


void packet_handler(char* ptr_packet_stack, int len_packet_stack)
{
	//TODO Olaf: packet handler
	/*Diese Funktion wird vom TCP-Prozess ausgefÃ¼hrt, wenn ein (oder mehrere) neue Pakete angekommen ist/sind.
	 *Die Funktion bekommt einen Pointer auf den Beginn des ersten Pakets und die GrÃ¶ÃŸe aller Pakete (also z.B. 150, wenn
	 *3 Pakete Ã  50 Byte angekommen sind).
	 *Auf Basis dieser Daten liest du bitte die Pakete aus und ruft je Pakettyp die entsprechende Funktion auf.
	 */
}


void packet_handler_type_1(char* ptr_packet)
{
	//TODO Olaf
	/*
	 * Diese Funktion behandelt die Pakete vom Pakettyp 1
	 * 1. Loope durch die 48 Byte (ab Byte 3 bis Byte 50) und lies die 12 Zutaten aus. Falls keine 12 Zutaten definiert sind,
	 * sind die restlichen Bytes = 0.
	 * Speichere sie in einem Array vom Typ module_ingredient_t[12] (Definition siehe ganz oben) ab.
	 * 		While-Schleife: solange != 0
	 * 2. Sortiere das Array nach Modulen
	 * 		Bubble Sort reicht...
	 * 3. HÃ¤nge die Zutaten an die entsprechenden Listen an
	 * Entgegen meiner Aussage musst du bei Dopplungen keine leeren EintrÃ¤ge generieren. Die Implementierung hat hierfÃ¼r
	 * die Variable lastInstruction bei dem Datentyp der Zutaten erstellt. Du kannst die doppelten Zutaten einfach nacheinander
	 * an die Liste anhÃ¤ngen, wobei du bei allen lastIntstruction=FALSE und nur beim letzen =TRUE machst.
	 * PrÃ¼fe einfach, ob die folgende Zutat die gleiche Modulnummer hat und setze lastInstruction dementsprechend
	 * 		mit if-Anweisung prüfen
	 * 4. HÃ¤nge an jedes nicht benutzte Modul einen leeren Eintrag an.
	 * 		Definition leerer Eintrag siehe oben
	 *
	 * Das anhÃ¤ngen an die Listen geschieht mit der Funktion list_append, welche einen pointer auf den die Liste
	 * und einen Eintrag des Datentypes ingredient_t (siehe Linked_List.h) bekommt.
	 */
}


void packet_handler_type_2()
{
	//TODO Olaf
	/*
	 * Checke, wie du die Anzahl der aktuell in Bearbeitung und ausstehenden Cocktails aus den Drink-Listen auslesen kannst
	 *
	 */

	//SchnÃ¼ren des Pakets (musst du nicht mehr verÃ¤ndern)
	ptr_packet = malloc(2+2*sizeof(int));
	*(ptr_packet+2) = inBearbeitung;
	*(ptr_packet+2+sizeof(int)) = imSpeicher;

	//TODO Philipp
	//packet an TCP weitergeben
}

void packet_handler_type_5()
{
	//TODO Olaf
	//Diese Pakete enthalten einen gewÃ¼nschten Systemzustand.
	//Diesen kannst du mehr oder weniger (einfach bei allem mal kurz drÃ¼ber nachdenken, wann wir es nicht machen sollten)
	//in system_state->General.operation_mode Ã¼bernehmen.

}



